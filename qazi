#!/usr/bin/env bash
set -Eeuo pipefail

# If run from pipe, get input from real terminal
if [[ ! -t 0 && -r /dev/tty ]]; then
  exec </dev/tty
fi

QAZI_DIR="/etc/qazi"
TUN_DIR="$QAZI_DIR/tunnels.d"

# ---------- UI ----------
print_header() {
  clear
  cat <<'ART'
      ____   ___   _______
     / __ \ / _ \ /__  __/
    / /_/ //  __/   / /
    \___\_\\___/   /_/

          QAZI
ART
  echo
  echo "Qazi - GOST Tunnel Manager (h2 / h2+tls)"
  echo "======================================================="
  echo
}

pause() { echo; read -rp "Press Enter to continue..."; }

die() { echo "❌ $*"; exit 1; }

need_root() {
  [[ "${EUID:-$(id -u)}" -eq 0 ]] || die "This program must be run as root. Example: sudo Qazi"
}

have() { command -v "$1" >/dev/null 2>&1; }

ensure_dirs() {
  mkdir -p "$TUN_DIR"
}

svc_name() { echo "qazi-$1.service"; }

systemd_ok() {
  have systemctl || die "systemctl not found (your system does not have systemd or it is incomplete)."
}

open_firewall_port() {
  local port="$1"
  if have ufw; then
    ufw allow "${port}/tcp" >/dev/null 2>&1 || true
  fi
}

gost_ok() {
  have gost || return 1
  return 0
}

install_or_update_gost() {
  print_header
  cat <<'TXT'
GOST Install/Update Guide:
- This will use the official GOST project installer:

  bash <(curl -fsSL https://github.com/go-gost/gost/raw/master/install.sh) --install

Notes:
- Internet connection required.
- If already installed, it will usually update.
TXT
  echo
  read -rp "Continue? (y/n): " yn
  [[ "$yn" =~ ^[Yy]$ ]] || return 0

  have curl || die "curl is not installed. (Use install.sh or install manually: apt install curl -y)"

  bash <(curl -fsSL https://github.com/go-gost/gost/raw/master/install.sh) --install

  echo
  echo "✅ GOST installed/updated."
  echo -n "Version: "
  gost -V || true
  pause
}

# ---------- Tunnel store ----------
conf_path() { echo "$TUN_DIR/$1.conf"; }

conf_exists() { [[ -f "$(conf_path "$1")" ]]; }

save_conf() {
  local name="$1"; shift
  local p; p="$(conf_path "$name")"
  {
    echo "# Qazi tunnel config"
    for kv in "$@"; do echo "$kv"; done
  } >"$p"
}

list_tunnels_quiet() {
  if compgen -G "$TUN_DIR/*.conf" >/dev/null; then
    for f in "$TUN_DIR"/*.conf; do basename "$f" .conf; done
  fi
}

# ---------- systemd service ----------
write_service() {
  local name="$1"
  local exec_cmd="$2"

  local unit="/etc/systemd/system/$(svc_name "$name")"
  cat >"$unit" <<EOF
[Unit]
Description=Qazi GOST Tunnel: ${name}
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
ExecStart=${exec_cmd}
Restart=always
RestartSec=2
LimitNOFILE=1048576

[Install]
WantedBy=multi-user.target
EOF

  systemctl daemon-reload
  systemctl enable "$(svc_name "$name")" >/dev/null 2>&1 || true
}

start_svc() {
  local name="$1"
  systemctl restart "$(svc_name "$name")"
}

stop_svc() {
  local name="$1"
  systemctl stop "$(svc_name "$name")" >/dev/null 2>&1 || true
}

status_svc() {
  local name="$1"
  systemctl status "$(svc_name "$name")" --no-pager || true
}

logs_svc() {
  local name="$1"
  print_header
  echo "Live logs for tunnel: $name"
  echo "To exit: q"
  echo
  journalctl -u "$(svc_name "$name")" -e -f
}

delete_tunnel() {
  print_header
  read -rp "Tunnel name to delete: " name
  conf_exists "$name" || { echo "❌ Tunnel not found."; pause; return; }

  read -rp "⚠️ Are you sure? (y/n): " yn
  [[ "$yn" =~ ^[Yy]$ ]] || return 0

  stop_svc "$name"
  systemctl disable "$(svc_name "$name")" >/dev/null 2>&1 || true
  rm -f "/etc/systemd/system/$(svc_name "$name")"
  rm -f "$(conf_path "$name")"
  systemctl daemon-reload

  echo "✅ Deleted."
  pause
}

# ---------- Wizard ----------
create_tunnel() {
  print_header
  gost_ok || { echo "❌ GOST is not installed. Run option 1 first."; pause; return; }
  systemd_ok

  cat <<'TXT'
Tunnel Creation Wizard:

Roles:
  1) Listener  (this server listens) ← usually foreign (Kharej) server
  2) Connector (this server connects) ← usually Iran server

Protocols:
  1) No TLS  : http2://
  2) With TLS: http+h2://    (h2 + TLS with GOST auto cert)

Note:
- If x-ui is running on 80/8080, choose a free port like 9090 for GOST.
TXT
  echo

  read -rp "Tunnel name (example: ir_to_out_80): " name
  name="${name// /_}"
  [[ -n "$name" ]] || { echo "❌ Name is empty."; pause; return; }
  ! conf_exists "$name" || { echo "❌ This name already exists."; pause; return; }

  echo
  echo "Role:"
  echo "  1) Listener"
  echo "  2) Connector"
  read -rp "Select (1/2): " role

  echo
  echo "Protocol:"
  echo "  1) No TLS (http2)"
  echo "  2) With TLS (http+h2)"
  read -rp "Select (1/2): " proto_sel
  local proto="http2"
  [[ "$proto_sel" == "2" ]] && proto="http+h2"

  echo
  read -rp "Enable authentication (user/pass)? (y/n): " use_auth
  local user="" pass=""
  if [[ "$use_auth" =~ ^[Yy]$ ]]; then
    read -rp "Username: " user
    read -rsp "Password: " pass
    echo
  fi

  if [[ "$role" == "1" ]]; then
    echo
    echo "Listener Settings:"
    read -rp "Tunnel port to listen on (example 9090): " tunnel_port
    read -rp "Destination inbound port (example 80): " inbound_port
    read -rp "Destination IP (default 127.0.0.1): " inbound_host_in
    local inbound_host="${inbound_host_in:-127.0.0.1}"

    [[ "$tunnel_port" =~ ^[0-9]+$ ]] || { echo "❌ Invalid tunnel port."; pause; return; }
    [[ "$inbound_port" =~ ^[0-9]+$ ]] || { echo "❌ Invalid inbound port."; pause; return; }

    open_firewall_port "$tunnel_port"

    local listen_url
    if [[ "$use_auth" =~ ^[Yy]$ ]]; then
      listen_url="${proto}://${user}:${pass}@:${tunnel_port}"
    else
      listen_url="${proto}://:${tunnel_port}"
    fi

    local exec_cmd="/usr/local/bin/gost -L ${listen_url} -F tcp://${inbound_host}:${inbound_port}"

    save_conf "$name" \
      "NAME=${name}" \
      "ROLE=listener" \
      "PROTO=${proto}" \
      "TUNNEL_PORT=${tunnel_port}" \
      "INBOUND_HOST=${inbound_host}" \
      "INBOUND_PORT=${inbound_port}" \
      "AUTH=${use_auth}" \
      "USER=${user}" \
      "PASS=${pass}"

    write_service "$name" "$exec_cmd"
    start_svc "$name"

    echo
    echo "✅ Listener created and started."
    echo "Path: ${proto}://:${tunnel_port}  →  tcp://${inbound_host}:${inbound_port}"
    pause
    return
  fi

  if [[ "$role" == "2" ]]; then
    echo
    echo "Connector Settings:"
    read -rp "Local port on this server (example 80): " local_port
    read -rp "Remote server IP (example 212.87.198.106): " remote_ip
    read -rp "Tunnel port on remote server (example 9090): " remote_port

    [[ "$local_port" =~ ^[0-9]+$ ]] || { echo "❌ Invalid local port."; pause; return; }
    [[ "$remote_port" =~ ^[0-9]+$ ]] || { echo "❌ Invalid remote port."; pause; return; }
    [[ -n "$remote_ip" ]] || { echo "❌ IP is empty."; pause; return; }

    local remote_url
    if [[ "$use_auth" =~ ^[Yy]$ ]]; then
      remote_url="${proto}://${user}:${pass}@${remote_ip}:${remote_port}"
    else
      remote_url="${proto}://${remote_ip}:${remote_port}"
    fi

    if [[ "$proto" == "http+h2" ]]; then
      echo
      echo "TLS is enabled."
      echo "If you enable Verify, the certificate will be checked."
      echo "Without a domain, you can use serverName=gost.run."
      read -rp "Enable TLS Verify (secure=true)? (y/n): " tv
      if [[ "$tv" =~ ^[Yy]$ ]]; then
        remote_url="${remote_url}?secure=true&serverName=gost.run"
      fi
    fi

    local exec_cmd="/usr/local/bin/gost -L tcp://:${local_port} -F ${remote_url}"

    save_conf "$name" \
      "NAME=${name}" \
      "ROLE=connector" \
      "PROTO=${proto}" \
      "LOCAL_PORT=${local_port}" \
      "REMOTE_IP=${remote_ip}" \
      "REMOTE_PORT=${remote_port}" \
      "AUTH=${use_auth}" \
      "USER=${user}" \
      "PASS=${pass}"

    write_service "$name" "$exec_cmd"
    start_svc "$name"

    echo
    echo "✅ Connector created and started."
    echo "Path: tcp://:${local_port}  →  ${remote_url}"
    pause
    return
  fi

  echo "❌ Invalid role."
  pause
}

# ---------- Management menus ----------
list_tunnels() {
  print_header
  echo "Existing tunnels:"
  echo "-------------------------------------------------------"
  local any=0
  while IFS= read -r t; do
    [[ -n "$t" ]] || continue
    any=1
    echo "• $t"
  done < <(list_tunnels_quiet || true)
  [[ "$any" -eq 1 ]] || echo "(No tunnels created)"
  echo "-------------------------------------------------------"
  pause
}

restart_tunnel() {
  print_header
  read -rp "Tunnel name: " name
  conf_exists "$name" || { echo "❌ Tunnel not found."; pause; return; }
  start_svc "$name"
  echo "✅ Started/restarted."
  pause
}

stop_tunnel() {
  print_header
  read -rp "Tunnel name: " name
  conf_exists "$name" || { echo "❌ Tunnel not found."; pause; return; }
  stop_svc "$name"
  echo "✅ Stopped."
  pause
}

status_tunnel() {
  print_header
  read -rp "Tunnel name: " name
  conf_exists "$name" || { echo "❌ Tunnel not found."; pause; return; }
  status_svc "$name"
  pause
}

logs_tunnel() {
  read -rp "Tunnel name: " name
  conf_exists "$name" || { echo "❌ Tunnel not found."; pause; return; }
  logs_svc "$name"
}

# ---------- Main ----------
menu() {
  while true; do
    print_header
    echo "1) Install/Update GOST (Official)"
    echo "2) Create New Tunnel (Wizard)"
    echo "3) List Tunnels"
    echo "4) Start Tunnel (Restart)"
    echo "5) Stop Tunnel"
    echo "6) Tunnel Status"
    echo "7) Tunnel Logs (Live)"
    echo "8) Delete Tunnel"
    echo "0) Exit"
    echo
    read -rp "Your choice: " c
    case "$c" in
      1) install_or_update_gost ;;
      2) create_tunnel ;;
      3) list_tunnels ;;
      4) restart_tunnel ;;
      5) stop_tunnel ;;
      6) status_tunnel ;;
      7) logs_tunnel ;;
      8) delete_tunnel ;;
      0) exit 0 ;;
      *) echo "Invalid option"; pause ;;
    esac
  done
}

need_root
ensure_dirs
menu
